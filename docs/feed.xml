<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="https://powershell.anovelidea.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://powershell.anovelidea.org/" rel="alternate" type="text/html" /><updated>2018-08-19T17:21:40-05:00</updated><id>https://powershell.anovelidea.org/</id><title type="html">PowerShell: What A Novel Idea</title><subtitle>A blog on PowerShell and IT</subtitle><author><name>Dave Carroll</name></author><entry><title type="html">Unique Email Domains</title><link href="https://powershell.anovelidea.org/powershell/unique-email-domains/" rel="alternate" type="text/html" title="Unique Email Domains" /><published>2018-08-17T00:00:00-05:00</published><updated>2018-08-17T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/powershell/unique-email-domains</id><content type="html" xml:base="https://powershell.anovelidea.org/powershell/unique-email-domains/">&lt;p&gt;So you’re working on getting all of your email domains that’s on-prem into Azure or you simply want to ensure that your
on-prem Exchange has been configured for all the domains your user accounts utilize. Your Active Directory domain
contains over 30,000 accounts. How would you go about discovering the unique email domains?&lt;/p&gt;

&lt;p&gt;Knowing that the Active Directory attribute proxyAddresses contains the account’s SMTP addreses, we can start there.
Also, you only want to include only those domains for active accounts. [Note: The proxyAddresses also contains other
address types, but we are only concerned about SMTP for this excercise.]&lt;/p&gt;

&lt;p&gt;First, let’s get all the proxyAddresses into a variable.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$Filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;proxyAddresses -like '*' -and enabled -eq 'true'&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ProxyAddresses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Get-ADUser&lt;/span&gt; -Filter &lt;span class=&quot;nv&quot;&gt;$Filter&lt;/span&gt; -Properties proxyAddresses | &lt;span class=&quot;nb&quot;&gt;Select-Object&lt;/span&gt; -ExpandProperty proxyAddresses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we will loop through each one, matching on only SMTP addresses. We split on the @ symbol and return the domain
portion.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$EmailDomains&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ProxyAddresses&lt;/span&gt;.ForEach&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; -match &lt;span class=&quot;s1&quot;&gt;'smtp'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;.Replace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'smtp:'&lt;/span&gt;,&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Split&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'@'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;1]
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;Notice:&lt;/strong&gt; I used the ForEach() method (available in PowerShell v4 and later), which is typically faster than the
ForEach-Object cmdlet or the foreach loop. You can use whichever you choose based on your PowerShell version.&lt;/p&gt;

&lt;p&gt;Finally, we use Sort-Object -Unique to get the unique domains.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$EmailDomains&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;Sort-Object&lt;/span&gt; -Unique

&lt;span class=&quot;c1&quot;&gt;# output&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# anovelidea.org&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# chronicgoogler.com&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# gmail.com&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, you could have dozens or more unique domains. This short exercise can also reveal typos in domains.&lt;/p&gt;

&lt;p&gt;Hopefully, this post was helpful to you in some way.&lt;/p&gt;

&lt;p&gt;Have a great day!&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;powershell&quot;]" /><category term="powershell" /><category term="exchange" /><summary type="html">So you’re working on getting all of your email domains that’s on-prem into Azure or you simply want to ensure that your on-prem Exchange has been configured for all the domains your user accounts utilize. Your Active Directory domain contains over 30,000 accounts. How would you go about discovering the unique email domains? Knowing that the Active Directory attribute proxyAddresses contains the account’s SMTP addreses, we can start there. Also, you only want to include only those domains for active accounts. [Note: The proxyAddresses also contains other address types, but we are only concerned about SMTP for this excercise.] First, let’s get all the proxyAddresses into a variable. $Filter = &quot;proxyAddresses -like '*' -and enabled -eq 'true'&quot; $ProxyAddresses = Get-ADUser -Filter $Filter -Properties proxyAddresses | Select-Object -ExpandProperty proxyAddresses Next, we will loop through each one, matching on only SMTP addresses. We split on the @ symbol and return the domain portion. $EmailDomains = $ProxyAddresses.ForEach( { if ($_ -match 'smtp') { $_.Replace('smtp:','').Split('@')[1] } }) Notice: I used the ForEach() method (available in PowerShell v4 and later), which is typically faster than the ForEach-Object cmdlet or the foreach loop. You can use whichever you choose based on your PowerShell version. Finally, we use Sort-Object -Unique to get the unique domains. $EmailDomains | Sort-Object -Unique # output # anovelidea.org # chronicgoogler.com # gmail.com Of course, you could have dozens or more unique domains. This short exercise can also reveal typos in domains. Hopefully, this post was helpful to you in some way. Have a great day!</summary></entry><entry><title type="html">Welcome to My PowerShell Blog</title><link href="https://powershell.anovelidea.org/blog/blog-inception/" rel="alternate" type="text/html" title="Welcome to My PowerShell Blog" /><published>2018-08-14T00:00:00-05:00</published><updated>2018-08-17T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/blog/blog-inception</id><content type="html" xml:base="https://powershell.anovelidea.org/blog/blog-inception/">&lt;p&gt;Greetings fellow PowerShell aficionados!&lt;/p&gt;

&lt;p&gt;I feel I must begin with a confession: I was not an early adopter of PowerShell.&lt;/p&gt;

&lt;p&gt;I began using PowerShell because I had no other choice. I needed to manage the Live@EDU environment at the college where I worked. Who had time to learn something that was only going to be used with that particular setup? Not this guy. Boy, was I wrong.&lt;/p&gt;

&lt;p&gt;The more I needed to do with my environment, the more PowerShell quietly raised its hand.&lt;/p&gt;

&lt;p&gt;In the summer of 2010, I took on the challenge of forcing myself to learn PowerShell by way of converting a complex set of VBScript scripts into PowerShell. In a few short weeks, perhaps with a couple all-nighters, I had crafted a replacement solution that connected to Orcale, Microsoft SQL, and MySQL databases. It interfaced with Active Directory, Live@EDU, and Sun One LDAP. It used a .Net log4j logging and dot sourced modularized code (some of which were my own functions). It was an amazing homebrew identity management solution.&lt;/p&gt;

&lt;p&gt;Each year after that, my PowerShell skills grew and grew. I had/have a PowerShell session open basically all of the time. As much as I could, I tried using PowerShell commands instead of the GUI.&lt;/p&gt;

&lt;p&gt;In 2012, I started working with someone that &lt;a href=&quot;https://www.ILovePowerShell.com&quot;&gt;loved PowerShell&lt;/a&gt; as much as I did. We challenged each other and learned from it. I wrote functions and dot-sourced them in my profile. I started dabbling in modules, but just didn’t make the time to delve fully into them.&lt;/p&gt;

&lt;p&gt;Over the last couple years, I switched from PowerShell ISE to VS Code, started using git repositories (internal and GitHub), and created my first few real modules.&lt;/p&gt;

&lt;p&gt;And I’ve decided to start blogging about PowerShell.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I’ve had the domain &lt;code class=&quot;highlighter-rouge&quot;&gt;anovelidea.org&lt;/code&gt; since early 2000. If you want a break from PowerShell and IT in general, you can check out &lt;a href=&quot;http://www.anovelidea.org&quot;&gt;my other website&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;blog&quot;]" /><category term="blog" /><category term="powershell" /><summary type="html">Greetings fellow PowerShell aficionados!...I've decided to start blogging about PowerShell.</summary></entry></feed>