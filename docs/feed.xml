<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="https://powershell.anovelidea.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://powershell.anovelidea.org/" rel="alternate" type="text/html" /><updated>2018-08-26T15:37:19-05:00</updated><id>https://powershell.anovelidea.org/</id><title type="html">PowerShell: What A Novel Idea</title><subtitle>A blog on PowerShell and IT</subtitle><author><name>Dave Carroll</name></author><entry><title type="html">Updatable Help</title><link href="https://powershell.anovelidea.org/powershell/updatable-help/" rel="alternate" type="text/html" title="Updatable Help" /><published>2018-08-25T00:00:00-05:00</published><updated>2018-08-25T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/powershell/updatable-help</id><content type="html" xml:base="https://powershell.anovelidea.org/powershell/updatable-help/">&lt;p&gt;PowerShell has provided a way to update the help files for modules since version 3.0.&lt;/p&gt;

&lt;p&gt;Since creating my first two modules, I have tried adding updatable help support, but came across a few issues. Tonight,
I finally resolved them for my module PoShEvents.&lt;/p&gt;

&lt;h2 id=&quot;github-bad-github-pages-good&quot;&gt;GitHub Bad, GitHub Pages Good&lt;/h2&gt;

&lt;p&gt;My module repository is in GitHub, and I originally thought that I could simply use the Raw view for my updatable help.
After all, I was successfully serving the online help version using the markdown files straight out of GitHub.&lt;/p&gt;

&lt;p&gt;GitHub, as it turns out, hosts their files in a way that is not compatible for updatable help.&lt;/p&gt;

&lt;p&gt;I am now using GitHub Pages for this blog and I wanted to give updatable help another try. This method of hosting works
as intended.&lt;/p&gt;

&lt;h2 id=&quot;building-updatable-help&quot;&gt;Building Updatable Help&lt;/h2&gt;

&lt;p&gt;Like most others, I have opted to use the module &lt;a href=&quot;https://github.com/PowerShell/platyPS&quot; target=&quot;_blank&quot;&gt;platyPS&lt;/a&gt; to
create my help files.&lt;/p&gt;

&lt;p&gt;This post focuses on solving the issues I had with updatable help. For instructions on how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;platyPS&lt;/code&gt; see any of
these sites.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://overpoweredshell.com/Module-Tools-Adding-Cmdlet-Help-With-PlatyPS/&quot; target=&quot;_blank&quot;&gt;Module Tools - Adding Cmdlet Help With PlatyPS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ntsystems.it/post/converting-powershell-help-a-website&quot; target=&quot;_blank&quot;&gt;Convert PowerShell Help to a Website&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I had already created the markdown files that I was serving via GitHub for online help and moved those into my blog
repository structure. I used &lt;code class=&quot;highlighter-rouge&quot;&gt;Update-MarkdownHelp&lt;/code&gt; to update them and noticed that my Jekyll front matter was largely
untouched – some entries were out of order.&lt;/p&gt;

&lt;p&gt;When I originally created the help files, I did not include the &lt;code class=&quot;highlighter-rouge&quot;&gt;-WithModulePage&lt;/code&gt; switch. I ran the &lt;code class=&quot;highlighter-rouge&quot;&gt;New-MarkdownHelp&lt;/code&gt;
and generated a clean set of help files into a temp folder just to harvest the module page. After placing the file into
the correct path, I updated the front matter for Download Help Link, Help Version, and Locale.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt; I also added additional front matter YAML to be used by Jekyll, namely layout, classes, and permalink.&lt;/p&gt;

&lt;p&gt;As the content for the help files had previously been updated, I didn’t have to do that again. If you’re starting from a
clean or initial run of &lt;code class=&quot;highlighter-rouge&quot;&gt;New-MarkdownHelp&lt;/code&gt;, you will need to update the content manually.&lt;/p&gt;

&lt;p&gt;Then, I recreated the external help file.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;New-ExternalHelp -Path .\powershell.anovelidea.org\modulehelp\PoShEvents -OutputPath .\PoShEvents\PoShEvents\en-US\ -Force
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing-updatable-help&quot;&gt;Testing Updatable Help&lt;/h2&gt;

&lt;p&gt;Once you have created the necessary help files, you will need to test that it will successully update the module help.&lt;/p&gt;

&lt;h3 id=&quot;local-source&quot;&gt;Local Source&lt;/h3&gt;

&lt;p&gt;First, let’s see if we can &lt;code class=&quot;highlighter-rouge&quot;&gt;Update-Help&lt;/code&gt; from the local source.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Update-Help -Module PoShEvents -SourcePath .\powershell.anovelidea.org\modulehelp\PoShEvents\ -Force -Verbose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;color: gold&quot; class=&quot;language-console highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;VERBOSE: Performing the operation &quot;Update-Help&quot; on target &quot;PoShEvents, Current Version: 0.2.1, Available Version: 0.2.1, UICulture: en-US&quot;.
VERBOSE: PoShEvents: Updated C:\PowerShell\GitHub\PoShEvents\PoShEvents\en-US\about_PoShEvents.help.txt. Culture en-US Version 0.2.1
VERBOSE: PoShEvents: Updated C:\PowerShell\GitHub\PoShEvents\PoShEvents\en-US\PoShEvents-help.xml. Culture en-US Version 0.2.1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This proves that the updatable help works when pulling from the local source.&lt;/p&gt;

&lt;h3 id=&quot;online-source&quot;&gt;Online Source&lt;/h3&gt;

&lt;p&gt;If the local source test is successful, you will need to upload the &lt;code class=&quot;highlighter-rouge&quot;&gt;*HelpInfo.xml&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*HelpContent.cab&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;*HelpContent.zip&lt;/code&gt; help files to the location indicated by the module’s &lt;code class=&quot;highlighter-rouge&quot;&gt;HelpInfoUri&lt;/code&gt;. After this is done, you should
verify that you can access the URL successfully by using &lt;code class=&quot;highlighter-rouge&quot;&gt;Invoke-WebRequest&lt;/code&gt;. Ideally, the StatusCode should be 200.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ModInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Get-Module -Name PoShEvents | &lt;span class=&quot;nb&quot;&gt;Select-Object&lt;/span&gt; -Property Name,Guid,HelpInfoURI
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Invoke-WebRequest&lt;/span&gt; -Uri &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ModInfo&lt;/span&gt;.HelpInfoUri&lt;span class=&quot;k&quot;&gt;)$(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ModInfo&lt;/span&gt;.Name&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ModInfo&lt;/span&gt;.Guid&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;_HelpInfo.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.StatusCode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My result was not ideal.&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;Invoke-WebRequest : The request was aborted: Could not create SSL/TLS secure channel.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I wished that I could say I immediately tested with &lt;code class=&quot;highlighter-rouge&quot;&gt;Invoke-WebRequest&lt;/code&gt;. That would have saved me about an hour going
down the rabbithole of trying to trace the &lt;code class=&quot;highlighter-rouge&quot;&gt;Update-Help&lt;/code&gt; command. It would really be nice if &lt;code class=&quot;highlighter-rouge&quot;&gt;Update-Help&lt;/code&gt; revealed more
internal workings when you use the &lt;code class=&quot;highlighter-rouge&quot;&gt;-Verbose&lt;/code&gt; switch.&lt;/p&gt;

&lt;h2 id=&quot;tls&quot;&gt;TLS&lt;/h2&gt;

&lt;p&gt;Checking the security protocol that my default PowerShell session used, I saw why my testing failed. I included the
TLS 1.2 protocol and tested the URL again successfully.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Net.ServicePointManager]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecurityProtocol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;color: whitesmoke&quot; class=&quot;language-console highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;Ssl3, Tls
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Net.ServicePointManager]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecurityProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecurityProtocolType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecurityProtocolType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tls11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecurityProtocolType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tls12&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice&quot;&gt;A quick search revealed that on February 8, 2018, &lt;a href=&quot;https://githubengineering.com/crypto-removal-notice/&quot; target=&quot;_blank&quot;&gt;GitHub discontinued the use of TLS 1.0 and TLS 1.1&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Update-Help -Name PoShEvents -Verbose -Force
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;color: gold&quot; class=&quot;language-console highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;go&quot;&gt;VERBOSE: Resolving URI: &quot;https://powershell.anovelidea.org/modulehelp/PoShEvents&quot;
VERBOSE: Your connection has been redirected to the following URI: &quot;http://powershell.anovelidea.org/modulehelp/PoShEvents/&quot;
VERBOSE: Performing the operation &quot;Update-Help&quot; on target &quot;PoShEvents, Current Version: 0.2.1, Available Version: 0.2.1, UICulture: en-US&quot;.
VERBOSE: PoShEvents: Updated C:\PowerShell\GitHub\PoShEvents\PoShEvents\en-US\about_PoShEvents.help.txt. Culture en-US Version 0.2.1
VERBOSE: PoShEvents: Updated C:\PowerShell\GitHub\PoShEvents\PoShEvents\en-US\PoShEvents-help.xml. Culture en-US Version 0.2.1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;setting-strong-cryptography-for-net-framework&quot;&gt;Setting Strong Cryptography for .Net Framework&lt;/h2&gt;

&lt;p&gt;Setting &lt;code class=&quot;highlighter-rouge&quot;&gt;[Net.ServicePointManager]::SecurityProtocol&lt;/code&gt;, as I did, only applies to the current PowerShell session. To make
the change permanent, I updated the registry.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# set strong cryptography on 64 bit .Net Framework (version 4 and above)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set-ItemProperty&lt;/span&gt; -Path &lt;span class=&quot;s1&quot;&gt;'HKLM:\SOFTWARE\Wow6432Node\Microsoft\.NetFramework\v4.0.30319'&lt;/span&gt; -Name &lt;span class=&quot;s1&quot;&gt;'SchUseStrongCrypto'&lt;/span&gt; -Value &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt; -Type DWord

&lt;span class=&quot;c1&quot;&gt;# set strong cryptography on 32 bit .Net Framework (version 4 and above)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set-ItemProperty&lt;/span&gt; -Path &lt;span class=&quot;s1&quot;&gt;'HKLM:\SOFTWARE\Microsoft\.NetFramework\v4.0.30319'&lt;/span&gt; -Name &lt;span class=&quot;s1&quot;&gt;'SchUseStrongCrypto'&lt;/span&gt; -Value &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt; -Type DWord
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;By using GitHub Pages, platyPS, and the appropriate TLS protocol, I’m finally serving updatable help for my module
&lt;a href=&quot;https://github.com/thedavecarroll/PoShEvents&quot; target=&quot;_blank&quot;&gt;PoShEvents&lt;/a&gt;.&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;powershell&quot;]" /><category term="update-help" /><category term="updatable help" /><category term="tls" /><category term="ssl" /><category term="platyps" /><category term="powershell" /><summary type="html">Updatable Help on GitHub Pages with platyPS</summary></entry><entry><title type="html">Clear DNS Server Cache</title><link href="https://powershell.anovelidea.org/powershell/clear-dns-server-cache/" rel="alternate" type="text/html" title="Clear DNS Server Cache" /><published>2018-08-21T00:00:00-05:00</published><updated>2018-08-21T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/powershell/clear-dns-server-cache</id><content type="html" xml:base="https://powershell.anovelidea.org/powershell/clear-dns-server-cache/">&lt;p&gt;How often have you needed to clear the DNS server cache?&lt;/p&gt;

&lt;p&gt;Regardless how many domain controllers in your environment, a few simple lines of PowerShell can clear the cache on all of them.&lt;/p&gt;

&lt;p&gt;First, we need to get the name of the domain. Of course, if you already know the name, you can simply use it.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$DomainName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Get-ADDomain&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;Select-Object&lt;/span&gt; -ExpandProperty DnsRoot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we find all name servers in the domain and show only the hostname.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$DomainControllers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Resolve-DnsName&lt;/span&gt; -Name &lt;span class=&quot;nv&quot;&gt;$DomainName&lt;/span&gt; -Type NS&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Where&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;.Type -eq &lt;span class=&quot;s1&quot;&gt;'NS'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;.NameHost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lastly, we excecute the clear command for each one.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$DomainControllers&lt;/span&gt;.ForEach&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clear&lt;/span&gt;-DnsServerCache -ComputerName &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; -Force &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, there are a few shortcuts you can do to get this to a one-liner.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Resolve-DnsName&lt;/span&gt; -Name &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Get-ADDomain&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;Select-Object&lt;/span&gt; -ExpandProperty DnsRoot -Type NS&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Where&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;.Type -eq &lt;span class=&quot;s1&quot;&gt;'NS'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;.NameHost.ForEach&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clear&lt;/span&gt;-DnsServerCache -ComputerName &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; -Force &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For more information, please see the following Microsoft docs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/module/dnsserver/clear-dnsservercache&quot; target=&quot;_blank&quot;&gt;Clear-DnsServerCache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Have a great day!&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;powershell&quot;]" /><category term="powershell" /><category term="dns" /><category term="dns cache" /><summary type="html">Clear the DNS server cache on all domain controllers</summary></entry><entry><title type="html">Unique Email Domains</title><link href="https://powershell.anovelidea.org/powershell/unique-email-domains/" rel="alternate" type="text/html" title="Unique Email Domains" /><published>2018-08-17T00:00:00-05:00</published><updated>2018-08-17T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/powershell/unique-email-domains</id><content type="html" xml:base="https://powershell.anovelidea.org/powershell/unique-email-domains/">&lt;p&gt;So you’re working on getting all of your email domains that’s on-prem into Azure or you simply want to ensure that your
on-prem Exchange has been configured for all the domains your user accounts utilize. Your Active Directory domain
contains over 30,000 accounts. How would you go about discovering the unique email domains?&lt;/p&gt;

&lt;p&gt;Knowing that the Active Directory attribute proxyAddresses contains the account’s SMTP addreses, we can start there.
Also, you only want to include only those domains for active accounts. [Note: The proxyAddresses also contains other
address types, but we are only concerned about SMTP for this excercise.]&lt;/p&gt;

&lt;p&gt;First, let’s get all the proxyAddresses into a variable.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$Filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;proxyAddresses -like '*' -and enabled -eq 'true'&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ProxyAddresses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Get-ADUser&lt;/span&gt; -Filter &lt;span class=&quot;nv&quot;&gt;$Filter&lt;/span&gt; -Properties proxyAddresses | &lt;span class=&quot;nb&quot;&gt;Select-Object&lt;/span&gt; -ExpandProperty proxyAddresses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we will loop through each one, matching on only SMTP addresses. We split on the @ symbol and return the domain
portion.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$EmailDomains&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ProxyAddresses&lt;/span&gt;.ForEach&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt; -match &lt;span class=&quot;s1&quot;&gt;'smtp'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;.Replace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'smtp:'&lt;/span&gt;,&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Split&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'@'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;1]
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;Notice:&lt;/strong&gt; I used the ForEach() method (available in PowerShell v4 and later), which is typically faster than the
ForEach-Object cmdlet or the foreach loop. You can use whichever you choose based on your PowerShell version.&lt;/p&gt;

&lt;p&gt;Finally, we use Sort-Object -Unique to get the unique domains.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$EmailDomains&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;Sort-Object&lt;/span&gt; -Unique

anovelidea.org
chronicgoogler.com
gmail.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, you could have dozens or more unique domains. This short exercise can also reveal typos in domains.&lt;/p&gt;

&lt;p&gt;Hopefully, this post was helpful to you in some way.&lt;/p&gt;

&lt;p&gt;Have a great day!&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;powershell&quot;]" /><category term="powershell" /><category term="exchange" /><category term="azure" /><summary type="html">Get unique email domains from proxyAddresses for Exchange or Azure.</summary></entry><entry><title type="html">Welcome to My PowerShell Blog</title><link href="https://powershell.anovelidea.org/blog/blog-inception/" rel="alternate" type="text/html" title="Welcome to My PowerShell Blog" /><published>2018-08-14T00:00:00-05:00</published><updated>2018-08-17T00:00:00-05:00</updated><id>https://powershell.anovelidea.org/blog/blog-inception</id><content type="html" xml:base="https://powershell.anovelidea.org/blog/blog-inception/">&lt;p&gt;Greetings fellow PowerShell aficionados!&lt;/p&gt;

&lt;p&gt;I feel I must begin with a confession: I was not an early adopter of PowerShell.&lt;/p&gt;

&lt;p&gt;I began using PowerShell because I had no other choice. I needed to manage the Live@EDU environment at the college where I worked. Who had time to learn something that was only going to be used with that particular setup? Not this guy. Boy, was I wrong.&lt;/p&gt;

&lt;p&gt;The more I needed to do with my environment, the more PowerShell quietly raised its hand.&lt;/p&gt;

&lt;p&gt;In the summer of 2010, I took on the challenge of forcing myself to learn PowerShell by way of converting a complex set of VBScript scripts into PowerShell. In a few short weeks, perhaps with a couple all-nighters, I had crafted a replacement solution that connected to Orcale, Microsoft SQL, and MySQL databases. It interfaced with Active Directory, Live@EDU, and Sun One LDAP. It used a .Net log4j logging and dot sourced modularized code (some of which were my own functions). It was an amazing homebrew identity management solution.&lt;/p&gt;

&lt;p&gt;Each year after that, my PowerShell skills grew and grew. I had/have a PowerShell session open basically all of the time. As much as I could, I tried using PowerShell commands instead of the GUI.&lt;/p&gt;

&lt;p&gt;In 2012, I started working with someone that &lt;a href=&quot;https://www.ILovePowerShell.com&quot; target=&quot;_blank&quot;&gt;loved PowerShell&lt;/a&gt; as much as I did. We challenged each other and learned from it. I wrote functions and dot-sourced them in my profile. I started dabbling in modules, but just didn’t make the time to delve fully into them.&lt;/p&gt;

&lt;p&gt;Over the last couple years, I switched from PowerShell ISE to VS Code, started using git repositories (internal and GitHub), and created my first few real modules.&lt;/p&gt;

&lt;p&gt;And I’ve decided to start blogging about PowerShell.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I’ve had the domain &lt;code class=&quot;highlighter-rouge&quot;&gt;anovelidea.org&lt;/code&gt; since early 2000. If you want a break from PowerShell and IT in general, you can check out &lt;a href=&quot;http://www.anovelidea.org&quot; target=&quot;_blank&quot;&gt;my other website&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content><author><name>Dave Carroll</name></author><category term="[&quot;blog&quot;]" /><category term="blog" /><category term="powershell" /><summary type="html">Greetings fellow PowerShell aficionados!...I've decided to start blogging about PowerShell.</summary></entry></feed>